-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Utility.Bootstrap.Credential where 

import DA.Foldable (forA_)
import DA.Map qualified as Map (fromList, lookup)
import Daml.Script
import Utility.Bootstrap.Util (queryFilterOrExecuteCid, waitForCid)
import Utility.Common.V0.Upgrades.CurrentVersion (CurrentVersion(..))
import Utility.Credential.App.V0.Service.Operator (OperatorService(..), OperatorService_AcceptUserServiceRequest(..))
import Utility.Credential.App.V0.Service.User (UserServiceRequest(..), UserService_AcceptFreeCredentialOffer(..), UserService_OfferFreeCredential(..))
import Utility.Credential.V0.Credential (Claim)

-- | Specifications for a single credential.
data CredentialSpec = CredentialSpec
  with
    issuer : Party
      -- ^ Issuer party.
    holder : Party
      -- ^ Holder party.
    id : Text
      -- ^ Credential ID.
    description : Text
      -- ^ Credential description.
    claims : [Claim]
      -- ^ Claims to store in the credential.
  deriving (Eq, Show)

-- | Specifications for the credential app.
data CredentialAppSpec = CredentialAppSpec
  with
    operator : Party
      -- ^ Operator party.
    dso : Party
      -- ^ DSO party.
    users : [Party]
      -- ^ Users to create services for.
    credentialSpecs : [CredentialSpec]
      -- ^ Credentials to store on ledger.
      -- These are free credentials, so no `CredentialBilling` contract will be created .
    packageId : Text
      -- ^ Specifies the package id to be used for submission by clients.
  deriving (Eq, Show)

-- | Bootstrap the credential app.
bootstrapCredentialApp : CredentialAppSpec -> Script ()
bootstrapCredentialApp CredentialAppSpec{operator; dso; users; credentialSpecs, packageId} = do
  debug "Bootstrapping credential app..."

  debug $ "Creating operator service for " <> partyToText operator
  operatorServiceCid <-
    queryFilterOrExecuteCid operator (\c -> c.operator == operator && c.dso == dso) do
      submit operator do createCmd OperatorService with operator; dso
  debug $ "Created operator service for " <> partyToText operator

  -- Create user services
  let
    createUserService user = do
      debug $ "Creating user service for " <> partyToText user
      userServiceRequestCid <-
        queryFilterOrExecuteCid user (\c -> c.operator == operator && c.user == user) do
          submit user do createCmd UserServiceRequest with operator; user
      waitForCid operator userServiceRequestCid
      queryFilterOrExecuteCid operator (\c -> c.operator == operator && c.user == user) do
        (.userServiceCid) <$> submit operator do
          exerciseCmd operatorServiceCid OperatorService_AcceptUserServiceRequest with
            userServiceRequestCid
  userServiceMap <- Map.fromList . zip users <$> mapA createUserService users
  let
    getUserService user = case Map.lookup user userServiceMap of
      Some userServiceCid -> userServiceCid
      None -> error "User service not found"

  -- Create current version contracts
  let createCurrentVersion packageName user = do
      debug $ "Create CurrentVersion (" <> show packageName <> ") contract for " <> partyToText user
      submit operator do
        createCmd CurrentVersion with packageIdInUse = None, ..

  forA_ users (createCurrentVersion "utility-credential-app-v0")

  -- Create credentials
  let
    createCredential CredentialSpec{issuer; holder; id; description; claims} = do
      debug $ "Creating credential for " <> partyToText holder <> " with id " <> id
      let
        issuerSvc = getUserService issuer
        holderSvc = getUserService holder
      credentialOfferCid <- queryFilterOrExecuteCid issuer
        ( \c -> c.issuer == issuer &&
                c.holder == holder &&
                c.id == id &&
                c.description == description &&
                c.claims == claims
        )
        do
          (.credentialOfferCid) <$> submit issuer do
            exerciseCmd issuerSvc UserService_OfferFreeCredential with
              holder; id; description; claims
      waitForCid holder credentialOfferCid
      queryFilterOrExecuteCid holder
        ( \c -> c.issuer == issuer &&
                c.holder == holder &&
                c.id == id &&
                c.description == description &&
                c.claims == claims
        )
        do
          (.credentialCid) <$> submit holder do
            exerciseCmd holderSvc UserService_AcceptFreeCredentialOffer with credentialOfferCid
  forA_ credentialSpecs createCredential

  pure ()