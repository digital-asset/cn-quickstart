-- Copyright (c) 2025 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Utility.Bootstrap.Util where
import DA.Time qualified as T
import DA.Text (isPrefixOf)
import Daml.Script

-- | Executes a script only when no contract is found on the ledger for the provided party.
-- Otherwise it will return the contract id of the queried contract. If multiple contracts are
-- found, throw an error.
queryOrExecuteCid : forall t. (Template t, HasEnsure t) => Party -> Script (ContractId t)
  -> Script (ContractId t)
queryOrExecuteCid party f = query @t party >>= processQuery f

-- | Same as `queryOrExecuteCid`, but can additionally pass a predicate used to filter contracts.
queryFilterOrExecuteCid : forall t. (Template t, HasEnsure t) => Party -> (t -> Bool)
  -> Script (ContractId t) -> Script (ContractId t)
queryFilterOrExecuteCid party predicate f = queryFilter @t party predicate >>= processQuery f

-- | HIDE
processQuery : Script (ContractId t) -> [(ContractId t, x)] -> Script (ContractId t)
processQuery f = \case
  [(cid, _)] -> pure cid
  [] -> f
  _ -> abort "Multiple contracts found."

-- | Wait until `party` can query the target template `contractId`. Abort after `n` retries.
-- This is used when a script requires synchronization across participant nodes.
waitForCid : (Template t, HasEnsure t) => Party -> ContractId t -> Script ()
waitForCid = queryWithRetries queryContractId tries

-- | HIDE
queryWithRetries : (Party -> ContractId t -> Script (Optional x)) -> Int -> Party -> ContractId t
  -> Script ()
queryWithRetries query tries p cid
  | tries <= 0 = abort $ "Cid " <> show cid <> " did not appear"
  | otherwise = do
    debug $ "Attempting to query for contract id " <> show cid
    r <- query p cid
    case r of
      None -> do
        sleep delay
        queryWithRetries query (tries - 1) p cid
      Some _ ->
        debug $ "Contract id found!"
  where
    delay = T.seconds 1

-- | Default number of tries.
tries : Int
tries = 20

-- | Find a party in the given list of party details.
findPartyInDetails : [PartyDetails] -> Text -> Optional PartyDetails
findPartyInDetails partyDetails roleName = do
  let rolePartyOptional pd = pd.displayName == Some (roleName) || isPrefixOf ("'" <> roleName <> "::") (show pd.party)
  find rolePartyOptional partyDetails 

-- | Find a party on the given participant.
findPartyOnParticipant : Text -> Text -> Script (Optional PartyDetails)
findPartyOnParticipant participantName roleName = do
  partyDetails <- filter (.isLocal) <$> listKnownPartiesOn (ParticipantName participantName)
  pure $ findPartyInDetails partyDetails roleName

-- | Find or create a party on the given participant.
findOrCreateParty : Text -> Text -> Script Party
findOrCreateParty participantName roleName = do
  result <- findPartyOnParticipant participantName roleName
  case result of
    Some pd -> pure pd.party
    None -> do
      let roleNameLocal = participantName <> "-" <> roleName
      partyDetails <- filter (.isLocal) <$> listKnownParties
      case findPartyInDetails partyDetails roleNameLocal of
        Some pd -> pure pd.party
        None -> do
          debug $ "Creating party: " <> roleNameLocal
          allocatePartyWithHint roleNameLocal (PartyIdHint roleNameLocal)
