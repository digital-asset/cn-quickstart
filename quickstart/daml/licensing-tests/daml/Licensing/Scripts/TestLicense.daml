module Licensing.Scripts.TestLicense where

import Daml.Script

import DA.Assert
import DA.Time
import DA.List (sortOn, head)

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationInstructionV1

import Splice.Testing.Registries.AmuletRegistry qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApi qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClient qualified as WalletClient
import Splice.Testing.Utils

import Licensing.License
import Licensing.AppInstall

-------------------------------------------------------------------------------
-- Shared helpers
-------------------------------------------------------------------------------

-- | Helper that performs common initialization for license tests:
--   1) Initialize Amulet registry
--   2) Allocate user/provider
--   3) Feature the app with the provider
--   4) Fund the user with some initial amulets
--   5) Submit an AppInstallRequest and accept it
--   6) Create a new License for the user
setupLicenseTest
  : Script
      ( ( AmuletRegistry.AmuletRegistry
        , Party
        , Party
        )
      , ContractId License
      )
setupLicenseTest = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  userParty <- allocatePartyExact "user"
  providerParty <- allocatePartyExact "provider"

  AmuletRegistry.featureApp registry providerParty
  AmuletRegistry.tapLockedAndUnlockedFunds registry userParty 100.0

  installReqCid <- submit userParty $ createCmd AppInstallRequest with
    dso = registry.dso
    provider = providerParty
    user = userParty
    meta = emptyMetadata

  installCid <- submit providerParty $
    exerciseCmd installReqCid AppInstallRequest_Accept with
      installMeta = emptyMetadata
      meta = emptyMetadata

  licenseResult <- submit providerParty $
    exerciseCmd installCid AppInstall_CreateLicense with
      params = LicenseParams with
        meta = emptyMetadata
  let licenseCid = licenseResult.licenseId

  pure ((registry, userParty, providerParty), licenseCid)


-- | Helper that initiates a license renewal request, returning the
--   corresponding contract ID and the instrument ID used.
initiateLicenseRenewal
  : Text               -- ^ Description of the renewal
  -> Decimal           -- ^ Renewal fee amount
  -> RelTime           -- ^ License extension duration
  -> (AmuletRegistry.AmuletRegistry, Party, Party)
  -> ContractId License
  -> Script (ContractId LicenseRenewalRequest, InstrumentId)
initiateLicenseRenewal description renewalFee extensionDuration (registry, userParty, providerParty) licenseCid = script do
  now <- getTime
  let paymentWindow = hours 2
  let instrumentId = InstrumentId { admin = registry.dso, id = "Amulet" }
  renewalRequestCid <- submit providerParty $
    exerciseCmd licenseCid License_Renew with
      licenseFeeInstrumentId = instrumentId
      licenseFeeAmount = renewalFee
      licenseExtensionDuration = extensionDuration
      paymentAcceptanceDuration = paymentWindow
      requestedAt = now
      prepareUntil = now `addRelTime` hours 1
      settleBefore = now `addRelTime` paymentWindow
      description
  pure (renewalRequestCid, instrumentId)


-- | Helper that finalizes the renewal workflow when the user accepts it.
--   1) The user obtains and verifies the requested allocation
--   2) The user allocates through the registry
--   3) Time is moved to allow finalization
--   4) The provider checks allocations for the given request, verifies,
--      and completes the renewal payment
acceptAndCompleteLicenseRenewal
  : (AmuletRegistry.AmuletRegistry, Party, Party)
  -> ContractId LicenseRenewalRequest
  -> Decimal
  -> InstrumentId
  -> Script ()
acceptAndCompleteLicenseRenewal (registry, userParty, providerParty) renewalRequestCid renewalFee instrumentId = script do
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  userHoldingCids <- WalletClient.listHoldingCids userParty instrumentId

  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = userAlloc
    inputHoldingCids = userHoldingCids
    extraArgs = emptyExtraArgs

  submitWithDisclosures' userParty enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  passTime (hours 1)

  Some renewalRequest <- queryContractId providerParty renewalRequestCid
  let renewalRef = (view $ toInterface @AllocationRequest renewalRequest).settlement.settlementRef
  allocations <- listAllocationsForRenewal providerParty renewalRef
  length allocations === 1

  let [(allocCid, _)] = allocations
  context <- RegistryApi.getAllocationTransferContext registry allocCid emptyMetadata
  let extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  submitWithDisclosures' providerParty context.disclosures $
    exerciseCmd renewalRequestCid LicenseRenewalRequest_CompleteRenewal with
      allocationInstruction = allocCid
      extraArgs = extraArgs
  pure ()


-------------------------------------------------------------------------------
-- Tests
-------------------------------------------------------------------------------

-- | New-style test that uses the token standard via 'LicenseRenewalRequest'.
--   This shows how to allocate a renewal payment for a 'License' using the
--   standard flows, mirroring the patterns from 'TestAmuletTokenDvP'.
testLicenseTokenStandard : Script ()
testLicenseTokenStandard = script do
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest

  -- Provider initiates a renewal request that implements the AllocationRequest interface
  -- We ask for a renewal fee of 20.0 amulets, to be paid by the user to the provider.
  (renewalRequestCid, instrumentId) <-
    initiateLicenseRenewal
      "Token-standard-based renewal"
      20.0
      (days 365)
      (registry, userParty, providerParty)
      licenseCid

  -- Check that the renewal request is present on the ledger
  Some renewalRequest <- queryContractId providerParty renewalRequestCid

  -- Complete the workflow of user acceptance and provider finalization
  acceptAndCompleteLicenseRenewal (registry, userParty, providerParty) renewalRequestCid 20.0 instrumentId

  -----------------------------------------------------
  -- Check that the renewal succeeded
  -----------------------------------------------------
  userHoldingsAfter <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsAfter <- WalletClient.listHoldings providerParty instrumentId
  debug userHoldingsAfter
  debug providerHoldingsAfter

  -- The old license is replaced with a new license having a year of extended validity
  newLicensesUser <- query @License userParty
  newLicensesProvider <- query @License providerParty
  debug newLicensesUser
  debug newLicensesProvider
  length newLicensesUser === 1
  length newLicensesProvider === 1
  let (_, newLicense) = head newLicensesUser
  now <- getTime
  assertMsg "License was extended by 365 days" $
    newLicense.expiresAt > now

  pure ()


testLicenseTokenStandard_RenewalRejection : Script ()
testLicenseTokenStandard_RenewalRejection = script do
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest

  (renewalRequestCid, instrumentId) <-
    initiateLicenseRenewal
      "Token-standard-based renewal"
      20.0
      (days 365)
      (registry, userParty, providerParty)
      licenseCid

  Some renewalRequest <- queryContractId providerParty renewalRequestCid

  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === 20.0

  userHoldingsBefore <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsBefore <- WalletClient.listHoldings providerParty instrumentId

  -- User rejects the renewal allocation request
  let renewalRequestIid = toInterfaceContractId @AllocationRequest renewalRequestCid
  submit userParty $ exerciseCmd renewalRequestIid AllocationRequest_Reject with
    actor = userParty
    extraArgs = ExtraArgs with
      context = emptyChoiceContext
      meta = emptyMetadata

  -- Confirm the renewal request is archived
  mRenewalRequest <- queryContractId providerParty renewalRequestCid
  assertEq None mRenewalRequest

  pure ()


-- | Test renewing a license that has already expired. Users should not pay for
--   time that has already passed. The new license should extend from the current
--   time if the old license is already expired.
testLicenseTokenStandard_ExpiredLicenseRenewal : Script ()
testLicenseTokenStandard_ExpiredLicenseRenewal = script do
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest

  -- Advance time enough so that the created license is expired
  passTime (days 365)

  Some oldLicense <- queryContractId userParty licenseCid
  let oldExpiry = oldLicense.expiresAt

  now <- getTime
  assertMsg "Expiry was in the past" $ oldExpiry < now

  -- Provider initiates a renewal request for an expired license
  (renewalRequestCid, instrumentId) <-
    initiateLicenseRenewal
      "Token-standard-based renewal for expired license"
      20.0
      (days 365)
      (registry, userParty, providerParty)
      licenseCid

  -- Accept and complete the renewal from the user/provider side
  acceptAndCompleteLicenseRenewal (registry, userParty, providerParty) renewalRequestCid 20.0 instrumentId
  paymentAcceptedTime <- getTime

  -- Verify a new license was created, with expiresAt = max(now, oldLicense.expiresAt) + 365 days
  newLicensesUser <- query @License userParty
  newLicensesProvider <- query @License providerParty
  length newLicensesUser === 1
  length newLicensesProvider === 1
  let (_, newLicense) = head newLicensesUser
  let expectedExpiry = addRelTime paymentAcceptedTime (days 365)
  newLicense.expiresAt === expectedExpiry

  -- Check final balances
  userHoldingsAfter <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsAfter <- WalletClient.listHoldings providerParty instrumentId
  debug userHoldingsAfter
  debug providerHoldingsAfter
  WalletClient.checkBalanceApprox userParty instrumentId 80.0
  WalletClient.checkBalanceApprox providerParty instrumentId 20.0
  pure ()


-- | For convenience, filter all allocations referencing a particular 'Reference'.
listAllocationsForRenewal : Party -> Reference -> Script [(ContractId Allocation, AllocationView)]
listAllocationsForRenewal p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some alloc) <- allocs
        guard (alloc.settlement.settlementRef == ref)
        pure (cid, alloc)
  pure $ sortOn (\(_, alloc) -> alloc.transferLegId) matchingAllocs
