module Licensing.Scripts.TestLicense where

import Daml.Script

import DA.Assert
import DA.Time
import DA.List (sortOn, head)
import DA.Foldable (forA_)
import DA.Optional (isNone)

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationInstructionV1

import Splice.Testing.Registries.AmuletRegistry qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApi qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClient qualified as WalletClient
import Splice.Testing.Utils

import Licensing.License
import Licensing.AppInstall

-------------------------------------------------------------------------------
-- Shared helpers
-------------------------------------------------------------------------------

{- |
  Helper that performs common initialization for license tests:

  1. Initialize Amulet registry (in this example, we use the default AmuletRegistry config).
  2. Allocate user/provider parties.
  3. Feature the app with the provider so they can receive any fees or rewards.
  4. Fund the user with some initial amulets (so they can pay license fees).
  5. Submit an AppInstallRequest (from the user) and accept it (by the provider),
     which creates an AppInstall contract.
  6. The provider creates a new License for the user.
-}
setupLicenseTest
  : Script
      ( ( AmuletRegistry.AmuletRegistry
        , Party
        , Party
        )
      , ContractId License
      )
setupLicenseTest = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  userParty <- allocatePartyExact "user"
  providerParty <- allocatePartyExact "provider"

  -- Feature the app with the provider so they can receive any fees/rewards
  AmuletRegistry.featureApp registry providerParty

  -- Give the user some initial amulets to fund license-related transactions
  AmuletRegistry.tapLockedAndUnlockedFunds registry userParty 100.0

  -- User submits an AppInstallRequest
  installReqCid <- submit userParty $ createCmd AppInstallRequest with
    provider = providerParty
    user = userParty
    meta = emptyMetadata

  -- Provider accepts the request, creating an AppInstall contract
  installCid <- submit providerParty $
    exerciseCmd installReqCid AppInstallRequest_Accept with
      installMeta = emptyMetadata
      meta = emptyMetadata

  -- Provider creates a new License for the user
  licenseResult <- submit providerParty $
    exerciseCmd installCid AppInstall_CreateLicense with
      params = LicenseParams with
        meta = emptyMetadata
  let licenseCid = licenseResult.licenseId

  pure ((registry, userParty, providerParty), licenseCid)

{- |
  Helper that initiates a license renewal request (by the provider), returning
  both the contract ID and the instrument ID used for payment.

  1. The provider exercises `License_Renew`.
  2. A `LicenseRenewalRequest` contract is created (which implements `AllocationRequest`).
  3. The user will eventually need to allocate funds to pay the renewal fee.
-}
initiateLicenseRenewal
  : Text               -- ^ Description of the renewal
  -> Decimal           -- ^ Renewal fee amount
  -> RelTime           -- ^ License extension duration
  -> (AmuletRegistry.AmuletRegistry, Party)
  -> ContractId License
  -> Text
  -> Script (ContractId LicenseRenewalRequest, InstrumentId, Text)
initiateLicenseRenewal description renewalFee extensionDuration (registry, providerParty) licenseCid requestId = script do
  now <- getTime

  -- We'll give the user 2 hours to pay before the renewal request expires
  let paymentWindow = hours 2

  -- In this demo we use the "Amulet" instrument from the same admin as the registry.
  let instrumentId = InstrumentId { admin = registry.dso, id = "Amulet" }

  -- Provider exercises License_Renew to create a LicenseRenewalRequest
  renewalRequestCid <- submit providerParty $
    exerciseCmd licenseCid License_Renew with
      requestId
      licenseFeeInstrumentId = instrumentId
      licenseFeeAmount = renewalFee
      licenseExtensionDuration = extensionDuration
      requestedAt = now
      prepareUntil = now `addRelTime` hours 1
      settleBefore = now `addRelTime` paymentWindow
      description

  pure (renewalRequestCid, instrumentId, requestId)

{- |
  Helper that finalizes the renewal workflow when the user accepts it:

  1. The user sees the renewal request in their wallet. Because `LicenseRenewalRequest`
     implements `AllocationRequest`, the user has a standard "requested allocation" to
     send the specified amount of amulets (license fee) to the provider.
  2. The user obtains their current holding IDs and then accepts (allocates) this request,
     passing it through the registry factory (`AllocationFactory_Allocate`).
  3. The provider queries the allocation referencing the LicenseRenewalRequest via a
     settlementRef. The provider finalizes the payment by calling
     `LicenseRenewalRequest_CompleteRenewal`.

  Once completed, the old license is replaced with a new license having extended validity.
-}
acceptAndCompleteLicenseRenewal
  : (AmuletRegistry.AmuletRegistry, Party, Party)
  -> ContractId LicenseRenewalRequest
  -> ContractId License
  -> Decimal
  -> InstrumentId
  -> Script ()
acceptAndCompleteLicenseRenewal (registry, userParty, providerParty)
                                renewalRequestCid
                                licenseCid
                                renewalFee
                                instrumentId = script do

  now <- getTime

  ----------------------------------------------------------------------------
  -- 1. The user sees the allocation request in their wallet
  ----------------------------------------------------------------------------
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  -- The user obtains their current holding IDs
  userHoldingCids <- WalletClient.listHoldingCids userParty instrumentId

  ----------------------------------------------------------------------------
  -- 2. The user accepts (allocates) the request by calling the registry factory
  ----------------------------------------------------------------------------
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = userAlloc
    requestedAt = now
    inputHoldingCids = userHoldingCids
    extraArgs = emptyExtraArgs

  submitWithDisclosures' userParty enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg


  ----------------------------------------------------------------------------
  -- 3. The provider checks the allocation for the given request
  ----------------------------------------------------------------------------
  -- The provider sees the single allocation in the system, with
  -- settlementRef referencing the renewal request
  Some renewalRequest <- queryContractId providerParty renewalRequestCid
  let renewalRef = (view $ toInterface @AllocationRequest renewalRequest).settlement.settlementRef
  (allocCid, _) <- fetchAllocationsForRenewal providerParty renewalRef

  ----------------------------------------------------------------------------
  -- 4. The provider completes the renewal payment by finalizing the allocation
  ----------------------------------------------------------------------------
  context <- RegistryApi.getAllocation_TransferContext registry allocCid emptyMetadata
  let extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  submitWithDisclosures' providerParty context.disclosures $
    exerciseCmd renewalRequestCid LicenseRenewalRequest_CompleteRenewal with
      allocationCid = allocCid
      licenseCid = licenseCid
      extraArgs = extraArgs

  pure ()

-------------------------------------------------------------------------------
-- Tests
-------------------------------------------------------------------------------

{- |
  Test uses the token standard via `LicenseRenewalRequest`.
  This shows how to allocate a renewal payment for a `License` using the
  standard flows, mirroring the patterns from `TestAmuletTokenDvP`.

  Overall flow:

  1. We set up a license scenario via `setupLicenseTest`.
  2. The provider initiates a renewal request, calling `initiateLicenseRenewal`.
  3. The user sees and accepts the requested allocation, then the provider
     completes the final renewal step, calling `acceptAndCompleteLicenseRenewal`.
  4. We verify that the license is replaced with a new one and that the
     userâ€™s amulet balances have transferred.
-}
testLicenseTokenStandard : Script ()
testLicenseTokenStandard = script do
  let initialUserBalance = 100.0
      renewalFee = 20.0
      extension = days 365
  -----------------------------------------------------
  -- 1. Setup the environment & create a base License
  -----------------------------------------------------
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest
  WalletClient.checkBalance userParty registry.instrumentId initialUserBalance

  -----------------------------------------------------
  -- 2. Provider initiates a renewal request
  -----------------------------------------------------
  (renewalRequestCid, instrumentId, _) <-
    initiateLicenseRenewal
      "Token-standard-based renewal"
      renewalFee
      extension
      (registry, providerParty)
      licenseCid
      "req-id-1"

  -- Check that the renewal request is present on the ledger
  Some _ <- queryContractId providerParty renewalRequestCid



  -----------------------------------------------------
  -- 3. Complete the user/provider acceptance & finalization
  -----------------------------------------------------
  acceptAndCompleteLicenseRenewal
    (registry, userParty, providerParty)
    renewalRequestCid
    licenseCid
    renewalFee
    instrumentId

  -----------------------------------------------------
  -- 4. Check that the renewal succeeded
  -----------------------------------------------------
  -- The user should have transferred 20 amulets to the provider.
  WalletClient.checkHoldingWithAmountExists providerParty registry.instrumentId renewalFee
  WalletClient.checkBalanceApprox userParty registry.instrumentId (initialUserBalance - renewalFee)

  -- License renewal request should be archived
  requests <- query @LicenseRenewalRequest providerParty
  length requests === 0

  -- The old license is replaced with a new license having a year of extended validity
  [newLicenseUser] <- query @License userParty
  [newLicenseProvider] <- query @License providerParty
  newLicenseUser === newLicenseProvider
  -- Confirm it is extended exactly 365 days
  now <- getTime
  let expectedExpiry = addRelTime now extension
  newLicenseUser._2.expiresAt === expectedExpiry    

  pure ()

{- |
  Test the case where the user rejects a license renewal request.
  The `LicenseRenewalRequest` implements the `AllocationRequest` interface,
  so the user can simply exercise the standard `AllocationRequest_Reject`
  choice to cancel it.

  Once rejected, the renewal request is archived, and no fee is transferred.
-}
testLicenseTokenStandard_RenewalRejection : Script ()
testLicenseTokenStandard_RenewalRejection = script do
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest

  -- Provider initiates a renewal request
  let renewalFee = 20.0
  (renewalRequestCid, instrumentId, _) <-
    initiateLicenseRenewal
      "Token-standard-based renewal"
      renewalFee
      (days 365)
      (registry, providerParty)
      licenseCid
      "req-id-1"

  -- Check the user sees the requested allocation of 20.0 amulets
  Some _ <- queryContractId providerParty renewalRequestCid
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  -- The user decides to reject this request
  let renewalRequestIid = toInterfaceContractId @AllocationRequest renewalRequestCid
  submit userParty $ exerciseCmd renewalRequestIid AllocationRequest_Reject with
    actor = userParty
    extraArgs = ExtraArgs with
      context = emptyChoiceContext
      meta = emptyMetadata

  -- Confirm the renewal request is archived
  mRenewalRequest <- queryContractId providerParty renewalRequestCid
  assertEq None mRenewalRequest

  pure ()

{- |
  Test renewing a license that has already expired. The user should **not** pay
  for time that has already passed, meaning the new license should extend from
  the current time if the old license is already expired.

  The flow is the same as `testLicenseTokenStandard`, but we pass enough time
  before renewal to let the old license expire first. Then, upon renewal,
  `LicenseRenewalRequest` ensures the new license's start is effectively "now"
  if the old expiry time is already in the past.
-}
testLicenseTokenStandard_ExpiredLicenseRenewal : Script ()
testLicenseTokenStandard_ExpiredLicenseRenewal = script do
  let initialUserBalance = 100.0
      renewalFee = 20.0
      extension = days 365
  -----------------------------------------------------
  -- 1. Setup the environment & create a base License
  -----------------------------------------------------
  ((registry, userParty, providerParty), licenseCid) <- setupLicenseTest
  WalletClient.checkBalance userParty registry.instrumentId initialUserBalance

  -- Advance time enough so that the created license is expired
  passTime extension

  -- Check that the license is indeed expired
  Some oldLicense <- queryContractId userParty licenseCid
  let oldExpiry = oldLicense.expiresAt
  now <- getTime
  assertMsg "Expiry was in the past" $ oldExpiry < now

  -----------------------------------------------------
  -- 2. Provider initiates a renewal request (for an expired license)
  -----------------------------------------------------
  (renewalRequestCid, instrumentId, _) <-
    initiateLicenseRenewal
      "Token-standard-based renewal for expired license"
      renewalFee
      extension
      (registry, providerParty)
      licenseCid
      "req-id-1"

  -----------------------------------------------------
  -- 3. The user accepts & finalizes the renewal
  -----------------------------------------------------
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  userHoldingCids <- WalletClient.listHoldingCids userParty instrumentId
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = userAlloc
    requestedAt = now
    inputHoldingCids = userHoldingCids
    extraArgs = emptyExtraArgs

  submitWithDisclosures' userParty enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  renewalTime <- getTime

  Some renewalRequest <- queryContractId providerParty renewalRequestCid
  let renewalRef = (view $ toInterface @AllocationRequest renewalRequest).settlement.settlementRef
  (allocCid, _) <- fetchAllocationsForRenewal providerParty renewalRef

  context <- RegistryApi.getAllocation_TransferContext registry allocCid emptyMetadata
  submitWithDisclosures' providerParty context.disclosures $
    exerciseCmd renewalRequestCid LicenseRenewalRequest_CompleteRenewal with
      allocationCid = allocCid
      licenseCid = licenseCid
      extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  -----------------------------------------------------
  -- 4. Check that a new license was created with extended validity from "now"
  -----------------------------------------------------
  [newLicenseUser] <- query @License userParty
  [newLicenseProvider] <- query @License providerParty
  newLicenseUser === newLicenseProvider

  -- The new licenseâ€™s expiry should be renewalTime + 365 days (because the old was expired)
  let expectedExpiry = addRelTime renewalTime extension
  newLicenseUser._2.expiresAt === expectedExpiry

  -- Check final balances
  WalletClient.checkBalanceApprox userParty instrumentId (initialUserBalance - renewalFee)
  WalletClient.checkBalanceApprox providerParty instrumentId renewalFee


  pure ()


testLicenseTokenStandard_ConcurrentRenewals : Script ()
testLicenseTokenStandard_ConcurrentRenewals = script do
  let initialUserBalance = 100.0
      renewalFee = 10.0
      extensionDuration = days 10
  --------------------------------------------------------------------------------
  -- 1. Setup the environment & create a base License
  --------------------------------------------------------------------------------
  ((registry, userParty, providerParty), originalLicenseCid) <- setupLicenseTest
  WalletClient.checkBalance userParty registry.instrumentId initialUserBalance

  now <- getTime

  --------------------------------------------------------------------------------
  -- 2. Provider initiates two renewal requests referencing the same license
  --------------------------------------------------------------------------------
  (r1Cid, instrumentId, requestId1) <-
    initiateLicenseRenewal
      "First concurrent renewal"
      renewalFee
      extensionDuration
      (registry, providerParty)
      originalLicenseCid
      "req-id-1"

  (r2Cid, _, requestId2) <-
    initiateLicenseRenewal
      "Second concurrent renewal"
      renewalFee
      extensionDuration
      (registry, providerParty)
      originalLicenseCid
      "req-id-2"

  --------------------------------------------------------------------------------
  -- 3. The user sees two requested allocations and allocates them both
  --------------------------------------------------------------------------------
  userAllocs <- WalletClient.listRequestedAllocations userParty instrumentId
  length userAllocs === 2

  forA_ userAllocs (\alloc -> do
    userHoldings <- WalletClient.listHoldings userParty instrumentId
    let unlockedHoldingCids = map fst $ filter (\(_, holding) -> isNone (holding.lock)) userHoldings

    enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
      expectedAdmin = registry.dso
      allocation = alloc
      requestedAt = now
      inputHoldingCids = unlockedHoldingCids
      extraArgs = emptyExtraArgs

    submitWithDisclosures' userParty enrichedChoice.disclosures $
      exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

    pure ()
    )


  --------------------------------------------------------------------------------
  -- 4. Finalize the first renewal request. This archives the original license
  --    and creates a new one with an extended expiry.
  --------------------------------------------------------------------------------
  renewalTime <- getTime

  (allocCid1, _) <- fetchAllocationsForRenewal providerParty (Reference requestId1 None)
  (allocCid2, _) <- fetchAllocationsForRenewal providerParty (Reference requestId2 None)

  context1 <- RegistryApi.getAllocation_TransferContext registry allocCid1 emptyMetadata
  submitWithDisclosures' providerParty context1.disclosures $
    exerciseCmd r1Cid LicenseRenewalRequest_CompleteRenewal with
      allocationCid = allocCid1
      licenseCid = originalLicenseCid
      extraArgs = ExtraArgs with
        context = context1.choiceContext
        meta = emptyMetadata

  --------------------------------------------------------------------------------
  -- 5. Now there's a new license contract (call it L1) from the first renewal.
  --    We finalize the second renewal request, referencing L1.
  --------------------------------------------------------------------------------
  afterFirstRenewUserLicenses <- query @License userParty
  length afterFirstRenewUserLicenses === 1
  let (l1Cid, _) = head afterFirstRenewUserLicenses

  context2 <- RegistryApi.getAllocation_TransferContext registry allocCid2 emptyMetadata
  submitWithDisclosures' providerParty context2.disclosures $
    exerciseCmd r2Cid LicenseRenewalRequest_CompleteRenewal with
      allocationCid = allocCid2
      licenseCid = l1Cid
      extraArgs = ExtraArgs with
        context = context2.choiceContext
        meta = emptyMetadata

  --------------------------------------------------------------------------------
  -- 6. Check that we have a final license (L2) with the combined extended expiry
  --------------------------------------------------------------------------------
  afterSecondRenewUserLicenses <- query @License userParty
  length afterSecondRenewUserLicenses === 1
  let (_, l2Details) = head afterSecondRenewUserLicenses

  let expectedExtra = extensionDuration + extensionDuration
  let expectedExpires = renewalTime `addRelTime` expectedExtra
  l2Details.expiresAt === expectedExpires

  --------------------------------------------------------------------------------
  -- The user should have paid 2x renewalFee in total, which should now be with
  -- the provider.
  --------------------------------------------------------------------------------
  WalletClient.checkBalanceApprox userParty instrumentId (initialUserBalance - (renewalFee + renewalFee))
  WalletClient.checkBalanceApprox providerParty instrumentId (renewalFee + renewalFee)

  pure ()


-------------------------------------------------------------------------------
-- Utility for matching allocations by 'Reference'
-------------------------------------------------------------------------------

fetchAllocationsForRenewal : Party -> Reference -> Script (ContractId Allocation, AllocationView)
fetchAllocationsForRenewal p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some alloc) <- allocs
        guard (alloc.allocation.settlement.settlementRef == ref)
        pure (cid, alloc)
  length matchingAllocs === 1        
  pure $ head $ sortOn (\(_, alloc) -> alloc.allocation.settlement.settlementRef.id) matchingAllocs
