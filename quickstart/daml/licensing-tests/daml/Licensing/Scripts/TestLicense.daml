module Licensing.Scripts.TestLicense where

import Daml.Script

import DA.Assert
import DA.Time
import DA.List (sortOn, head)

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationInstructionV1

import Splice.Testing.Registries.AmuletRegistry qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApi qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClient qualified as WalletClient
import Splice.Testing.Utils

import Licensing.License
import Licensing.AppInstall


-- | New-style test that uses the token standard via 'LicenseRenewalRequest'.
--   This shows how to allocate a renewal payment for a 'License' using the
--   standard flows, mirroring the patterns from 'TestAmuletTokenDvP'.
testLicenseTokenStandard : Script ()
testLicenseTokenStandard = script do
  -- Initialize the registry (in this example, we use an Amulet registry).
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  -- Allocate parties
  userParty <- allocatePartyExact "user"
  providerParty <- allocatePartyExact "provider"

  -- Feature the app with the provider so that they can receive any fees/rewards.
  AmuletRegistry.featureApp registry providerParty

  -- Give the user some initial amulets to fund the license renewal
  AmuletRegistry.tapLockedAndUnlockedFunds registry userParty 100.0

  -- Create an AppInstallRequest by the user
  installReqCid <- submit userParty $ createCmd AppInstallRequest with
    dso = registry.dso
    provider = providerParty
    user = userParty
    meta = emptyMetadata

  -- Provider accepts the request, creating the AppInstall
  installCid <- submit providerParty $
    exerciseCmd installReqCid AppInstallRequest_Accept with
      installMeta = emptyMetadata
      meta = emptyMetadata

  -- Provider creates a new license for the user
  licenseResult <- submit providerParty $
    exerciseCmd installCid AppInstall_CreateLicense with
      params = LicenseParams with
        meta = emptyMetadata
  let licenseCid = licenseResult.licenseId

  -- Time-based bounds for demonstration. The license renewal request uses
  -- 'paymentAcceptanceDuration' to specify the settlement window.
  now <- getTime

  -- Provider initiates a renewal request that implements the AllocationRequest interface
  -- We ask for a renewal fee of 20.0 amulets, to be paid by the user to the provider.
  let renewalFee = 20.0
  let paymentWindow = hours 2
  let instrumentId = InstrumentId { admin = registry.dso, id = "Amulet" }
  renewalRequestCid <- submit providerParty $
    exerciseCmd licenseCid License_Renew with
      licenseFeeInstrumentId = instrumentId
      licenseFeeAmount = renewalFee
      licenseExtensionDuration = days 365
      paymentAcceptanceDuration = paymentWindow
      requestedAt = now
      prepareUntil = now `addRelTime` hours 1
      settleBefore = now `addRelTime` paymentWindow
      description = "Token-standard-based renewal"

  -- Check that the renewal request is present on the ledger
  Some renewalRequest <- queryContractId providerParty renewalRequestCid

  -----------------------------------------------------
  -- The user sees the allocation request in their wallet
  --
  -- Because 'LicenseRenewalRequest' implements 'AllocationRequest', the user has a
  -- standard "requested allocation" to send 20 amulets to the provider.
  -----------------------------------------------------
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  -- The user obtains their current holding IDs
  userHoldingCids <- WalletClient.listHoldingCids userParty instrumentId

  -- The user then accepts (allocates) this request, passing it through the registry factory
  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = userAlloc
    inputHoldingCids = userHoldingCids
    extraArgs = emptyExtraArgs

  submitWithDisclosures' userParty enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  -- Check that the user has locked part of their holding for settlement
  [(_, lockedHolding)] <- WalletClient.listLockedHoldings userParty instrumentId
  let expectedLock = Some $ Lock with
        expiresAt = Some (now `addRelTime` paymentWindow)
        expiresAfter = None
        holders = [registry.dso]
        context = Some "allocation for transfer leg 0 to 'provider'"
  lockedHolding.lock === expectedLock

  -- Advance time to allow the user to finalize their acceptance
  passTime (hours 1)

  -- The provider sees the single allocation in the system, with
  -- the settlementRef referencing the license renewal request
  let renewalRef = (view $ toInterface @AllocationRequest renewalRequest).settlement.settlementRef
  allocations <- listAllocationsForRenewal providerParty renewalRef
  length allocations === 1

  -- Compare the actual allocation with the expected allocation view before completing renewal
  let [(allocCid, actualView)] = allocations

  let singleLeg = Api.Token.AllocationV1.TransferLeg
        with
          sender = renewalRequest.user
          receiver = renewalRequest.provider
          amount = renewalRequest.licenseFeeAmount
          instrumentId = renewalRequest.licenseFeeInstrumentId
          meta = emptyMetadata

  let settlementInfo = SettlementInfo
        with
          executor = renewalRequest.provider
          requestedAt = renewalRequest.createdAt
          allocateBefore = renewalRequest.prepareUntil
          settleBefore = renewalRequest.settleBefore
          settlementRef =
            Reference
              with
                id = "LicenseRenewalRequest"
                cid = Some (coerceContractId renewalRequest.licenseCid)

  let expectedAllocationView = AllocationView
        with
          settlement = settlementInfo
          transferLegId = 0
          transferLeg = singleLeg
          meta = emptyMetadata

  actualView === expectedAllocationView

  -- The provider completes the renewal by finalizing the payment
  context <- RegistryApi.getAllocationTransferContext registry allocCid emptyMetadata
  let disclosures = context.disclosures
  let extraArgs = ExtraArgs with
        context = context.choiceContext
        meta = emptyMetadata

  submitWithDisclosures' providerParty disclosures $
    exerciseCmd renewalRequestCid LicenseRenewalRequest_CompleteRenewal with
      allocationInstruction = allocCid
      extraArgs = extraArgs

  -----------------------------------------------------
  -- Check that the renewal succeeded
  -----------------------------------------------------
  -- The user should have transferred 20 amulets to the provider.
  userHoldingsAfter <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsAfter <- WalletClient.listHoldings providerParty instrumentId
  debug userHoldingsAfter
  debug providerHoldingsAfter

  -- The old license is replaced with a new license having a year of extended validity
  newLicensesUser <- query @License userParty
  newLicensesProvider <- query @License providerParty
  debug newLicensesUser
  debug newLicensesProvider
  length newLicensesUser === 1
  length newLicensesProvider === 1
  let (_, newLicense) = head newLicensesUser
  assertMsg "License was extended by 365 days" $
    newLicense.expiresAt > now

  pure ()

testLicenseTokenStandard_RenewalRejection : Script ()
testLicenseTokenStandard_RenewalRejection = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig
  userParty <- allocatePartyExact "user"
  providerParty <- allocatePartyExact "provider"

  AmuletRegistry.featureApp registry providerParty
  AmuletRegistry.tapLockedAndUnlockedFunds registry userParty 100.0

  installReqCid <- submit userParty $ createCmd AppInstallRequest with
    dso = registry.dso
    provider = providerParty
    user = userParty
    meta = emptyMetadata

  installCid <- submit providerParty $
    exerciseCmd installReqCid AppInstallRequest_Accept with
      installMeta = emptyMetadata
      meta = emptyMetadata

  licenseResult <- submit providerParty $
    exerciseCmd installCid AppInstall_CreateLicense with
      params = LicenseParams with
        meta = emptyMetadata

  let licenseCid = licenseResult.licenseId

  now <- getTime

  let renewalFee = 20.0
  let paymentWindow = hours 2
  let instrumentId = InstrumentId { admin = registry.dso, id = "Amulet" }
  renewalRequestCid <- submit providerParty $
    exerciseCmd licenseCid License_Renew with
      licenseFeeInstrumentId = instrumentId
      licenseFeeAmount = renewalFee
      licenseExtensionDuration = days 365
      paymentAcceptanceDuration = paymentWindow
      requestedAt = now
      prepareUntil = now `addRelTime` hours 1
      settleBefore = now `addRelTime` paymentWindow
      description = "Token-standard-based renewal"

  Some renewalRequest <- queryContractId providerParty renewalRequestCid

  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  userHoldingsBefore <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsBefore <- WalletClient.listHoldings providerParty instrumentId

  -- User rejects the renewal allocation request using the AllocationRequest interface
  let renewalRequestIid = toInterfaceContractId @AllocationRequest renewalRequestCid
  submit userParty $ exerciseCmd renewalRequestIid AllocationRequest_Reject with
    actor = userParty
    extraArgs = ExtraArgs with
      context = emptyChoiceContext
      meta = emptyMetadata

  -- Confirm the renewal request is archived
  mRenewalRequest <- queryContractId providerParty renewalRequestCid
  assertEq None mRenewalRequest

  pure ()

-- | For convenience, filter all allocations referencing a particular 'Reference'.
listAllocationsForRenewal : Party -> Reference -> Script [(ContractId Allocation, AllocationView)]
listAllocationsForRenewal p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some alloc) <- allocs
        guard (alloc.settlement.settlementRef == ref)
        pure (cid, alloc)
  pure $ sortOn (\(_, alloc) -> alloc.transferLegId) matchingAllocs
