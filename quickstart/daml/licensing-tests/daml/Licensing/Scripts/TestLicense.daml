module Licensing.Scripts.TestLicense where

import Daml.Script

import DA.Action (unless)
import DA.Assert
-- import DA.Foldable
import DA.Time
import DA.List (sortOn, head)

import Splice.Api.Token.MetadataV1 as Api.Token.MetadataV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationInstructionV1

import Splice.Testing.Registries.AmuletRegistry qualified as AmuletRegistry
import Splice.Testing.TokenStandard.RegistryApi qualified as RegistryApi
import Splice.Testing.TokenStandard.WalletClient qualified as WalletClient
import Splice.Testing.Utils

import Licensing.License
import Licensing.AppInstall
import Licensing.Util


-- | New-style test that uses the token standard via 'LicenseRenewalRequest'.
--   This shows how to allocate a renewal payment for a 'License' using the
--   standard flows, mirroring the patterns from 'TestAmuletTokenDvP'.
testLicenseTokenStandard : Script ()
testLicenseTokenStandard = script do
  registry <- AmuletRegistry.initialize AmuletRegistry.defaultAmuletRegistryConfig

  userParty <- allocatePartyExact "user"
  providerParty <- allocatePartyExact "provider"

  AmuletRegistry.featureApp registry providerParty
  AmuletRegistry.tapLockedAndUnlockedFunds registry userParty 100.0

  -- Create an AppInstallRequest by the user
  installReqCid <- submit userParty $ createCmd AppInstallRequest with
    dso = registry.dso
    provider = providerParty
    user = userParty
    meta = emptyMetadata

  -- Provider accepts the request, creating the AppInstall
  installCid <- submit providerParty $
    exerciseCmd installReqCid AppInstallRequest_Accept with
      installMeta = emptyMetadata
      meta = emptyMetadata

  licenseResult <- submit providerParty $
    exerciseCmd installCid AppInstall_CreateLicense with
      params = LicenseParams with
        meta = emptyMetadata
  let licenseCid = licenseResult.licenseId

  now <- getTime
  let renewalFee = 20.0
  let paymentWindow = hours 2
  renewalRequestCid <- submit providerParty $
    exerciseCmd licenseCid License_Renew with
      licenseFeeAmount = renewalFee
      licenseExtensionDuration = days 365
      paymentAcceptanceDuration = paymentWindow
      description = "Token-standard-based renewal"

  Some renewalRequest <- queryContractId providerParty renewalRequestCid

  let instrumentId = InstrumentId { admin = registry.dso, id = "Amulet" }
  [userAlloc] <- WalletClient.listRequestedAllocations userParty instrumentId
  userAlloc.transferLeg.amount === renewalFee

  userHoldingCids <- WalletClient.listHoldingCids userParty instrumentId

  enrichedChoice <- RegistryApi.getAllocationFactory registry AllocationFactory_Allocate with
    expectedAdmin = registry.dso
    allocation = userAlloc
    inputHoldingCids = userHoldingCids
    extraArgs = emptyExtraArgs

  submitWithDisclosures' userParty enrichedChoice.disclosures $
    exerciseCmd enrichedChoice.factoryCid enrichedChoice.arg

  [(_, lockedHolding)] <- WalletClient.listLockedHoldings userParty instrumentId
  let expectedLock = Some $ Lock with
        expiresAt = Some (now `addRelTime` paymentWindow)
        expiresAfter = None
        holders = [registry.dso]
        context = Some "allocation for transfer leg 0 to 'provider'"
  lockedHolding.lock === expectedLock

  passTime (hours 1)

  let renewalRef = (view $ toInterface @AllocationRequest renewalRequest).settlement.settlementRef
  allocations <- listAllocationsForRenewal providerParty renewalRef
  length allocations === 1

  let [(allocCid, _)] = allocations
  submit providerParty $
    exerciseCmd renewalRequestCid LicenseRenewalRequest_CompleteRenewal with
      allocationInstructions = [allocCid]
      extraArgss = []

  userHoldingsAfter <- WalletClient.listHoldings userParty instrumentId
  providerHoldingsAfter <- WalletClient.listHoldings providerParty instrumentId
  debug userHoldingsAfter
  debug providerHoldingsAfter

  newLicensesUser <- query @License userParty
  newLicensesProvider <- query @License providerParty
  debug newLicensesUser
  debug newLicensesProvider
  length newLicensesUser === 1
  length newLicensesProvider === 1
  let (_, newLicense) = head newLicensesUser
  assertMsg "License was extended by 365 days" $
    newLicense.expiresAt > now

  pure ()


-- | For convenience, filter all allocations referencing a particular 'Reference'.
listAllocationsForRenewal : Party -> Reference -> Script [(ContractId Allocation, AllocationView)]
listAllocationsForRenewal p ref = do
  allocs <- queryInterface @Allocation p
  let matchingAllocs = do
        (cid, Some alloc) <- allocs
        guard (alloc.settlement.settlementRef == ref)
        pure (cid, alloc)
  pure $ sortOn (\(_, alloc) -> alloc.transferLegId) matchingAllocs

