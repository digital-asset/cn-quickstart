-- Copyright (c) 2025, Digital Asset (Switzerland) GmbH and/or its affiliates.
-- SPDX-License-Identifier: 0BSD
--
-- | A license contract for a CN application that allows the app provider
--   to charge a fee for renewing the license. The fee is collected using
--   the token standard. This license is not itself a token instrument.
module Licensing.License where

import DA.Time
import DA.Assert (assertWithinDeadline, assertDeadlineExceeded, (===))
import DA.Optional (fromSome)
import DA.TextMap as TextMap

import Licensing.Util as Util (require)
import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1

-- | Parameters determining the license behavior.
data LicenseParams = LicenseParams
  with
    meta : Metadata -- ^ Machine-readable metadata for this license.
  deriving (Eq, Show)

-- | A license contract between an app provider and an app user to use the app.
template License
  with
    provider : Party -- ^ Party identifying the app provider
    user : Party -- ^ Party identifying the app user
    expiresAt : Time -- ^ When the license expires. The license is not valid after this time.
    licenseNum : Int 
      -- ^ The license number.
      -- Its uniqueness depends on `AppInstall`s being unique.
      -- Alternatively storing a UUID chosen by the app provider as a globally unique
      -- license ID is a good option as well. 
    params : LicenseParams
  where
    signatory provider, user

    -- | Renews this license by collecting a fee from the user
    --   via the token standard. The actual settlement flow
    --   is defined by the corresponding LicenseRenewalRequest.
    nonconsuming choice License_Renew : ContractId LicenseRenewalRequest
      with
        requestId : Text
        licenseFeeInstrumentId : InstrumentId
        licenseFeeAmount : Decimal
        licenseExtensionDuration : RelTime
        requestedAt : Time
        prepareUntil : Time
        settleBefore : Time
        description : Text
      controller provider
      do
        assertDeadlineExceeded "requestedAt" requestedAt
        assertWithinDeadline "prepareUntil" prepareUntil
        require "prepareUntil < settleBefore" (prepareUntil < settleBefore)
        create LicenseRenewalRequest with
          requestId
          provider
          user
          licenseNum
          licenseFeeAmount
          licenseFeeInstrumentId
          licenseExtensionDuration
          prepareUntil
          settleBefore
          requestedAt
          description

    -- | Used if a provider/user chooses to mark the license as expired
    --   once the time has actually passed.
    choice License_Expire : ()
      with
        actor : Party
        meta : Metadata
      controller actor
      do
        require "Actor is a signatory" (actor `elem` signatory this)
        assertDeadlineExceeded "expiresAt" expiresAt

-- | A request to renew a license. This is where the token-standard-based
--   fee settlement is driven. The user is asked to pay the renewal fee
--   to the provider. Once settled, the old license is archived and a new
--   license with extended validity is created.
template LicenseRenewalRequest
  with
    requestId : Text -- ^ Globally unique id for this renewal request (e.g. a UUID)
    provider : Party -- ^ Party identifying the app provider
    user : Party -- ^ Party identifying the app user
    licenseNum : Int -- ^ The license number
    licenseFeeAmount : Decimal -- ^ The amount to be paid for the license renewal
    licenseFeeInstrumentId : InstrumentId -- ^ The instrument used for the license fee payment
    licenseExtensionDuration : RelTime -- ^ The duration for which the license is extended
    prepareUntil : Time -- ^ Until when (exclusive) the senders are given time to allocate their assets.
    settleBefore : Time
      -- ^ Until when (exclusive) the executor is given time to execute the settlement.
      --
      -- SHOULD be strictly after `prepareUntil`.
    requestedAt : Time -- ^ When the settlement was requested
    description : Text -- ^ Reason for renewal   

  where
    signatory user, provider

    -- | Completes the renewal by finalizing the token-standard-based fee
    --   transfer via Allocation and creating the new license state.
    --
    --   Once the license fee is transferred, the old license is archived
    --   and replaced with a new license with extended validity.
    postconsuming choice LicenseRenewalRequest_CompleteRenewal : ContractId License
      with
        allocationCid : ContractId Allocation
        licenseCid : ContractId License
        extraArgs : ExtraArgs
      controller provider
      do
        assertWithinDeadline "settleBefore" settleBefore

        alloc <- fetch @Allocation allocationCid  
        let allocView = view @Allocation alloc
            thisView = view $ toInterface @AllocationRequest this
            expectedTransferLegId = licenseFeePaymentLegId
            expectedTransferLeg = fromSome $ TextMap.lookup expectedTransferLegId thisView.transferLegs
            expectedSettlement = thisView.settlement

        -- validate that allocation is for this license renewal request
        expectedTransferLegId === allocView.allocation.transferLegId
        expectedTransferLeg === allocView.allocation.transferLeg
        expectedSettlement === allocView.allocation.settlement

        exercise allocationCid (Allocation_ExecuteTransfer extraArgs)

        oldLicense <- fetch licenseCid
        archive licenseCid

        -- validate that the old license is the one that is being renewed
        licenseNum === oldLicense.licenseNum
        user === oldLicense.user
        provider === oldLicense.provider


        now <- getTime
        create oldLicense
          with
            expiresAt = (max now oldLicense.expiresAt) `addRelTime` licenseExtensionDuration

    interface instance AllocationRequest for LicenseRenewalRequest where
      view =
        let
          meta = Metadata with
            values = TextMap.fromList [
              ("splice.lfdecentralizedtrust.org/reason", description)
              -- Communicate the license number for disambiguation using app specific 
              -- metadata as per https://github.com/global-synchronizer-foundation/cips/blob/main/cip-0056/cip-0056.md#generic-metadata
              ,("cn-quickstart.example.org/licenseNum", show licenseNum)
              ]
        in
          AllocationRequestView
            with
              settlement =
                SettlementInfo
                  with
                    executor = provider
                    requestedAt
                    allocateBefore = prepareUntil
                    settleBefore
                    settlementRef =
                      Reference
                        with
                          id = requestId
                          cid = None
                    meta
              transferLegs = TextMap.fromList
                [(licenseFeePaymentLegId, Api.Token.AllocationV1.TransferLeg
                    with
                      sender = user
                      receiver = provider
                      amount = licenseFeeAmount
                      instrumentId = licenseFeeInstrumentId
                      meta)
                ]
              meta

      allocationRequest_RejectImpl _ AllocationRequest_Reject{..} = do
        require "Actor is the user paying the fee" (actor == user)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _ _ =
        pure ChoiceExecutionMetadata with meta = emptyMetadata

licenseFeePaymentLegId = "licenseFeePayment"
