-- Copyright (c) 2025, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: 0BSD

-- | A license contract for a CN application that allows the app provider charge
-- a fee and share some of the app rewards that they get back with their users.
--
-- See the comments on the License template and its choices for design rationale.
module Licensing.License where

import Splice.Wallet.Payment
import Splice.AmuletRules (AppTransferContext(..))
import Splice.Round
import Splice.Util
import DA.Time
import DA.Assert
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Splice.Api.Token.MetadataV1

-- License contract template
----------------------------

-- | Parameters determining the license behavior.
data LicenseParams = LicenseParams with
    meta : Metadata -- ^ Machine-readable metadata for this license.
  deriving (Eq, Show)

data Group = Group
  with
    user : Party
    provider : Party
    dso: Party
  deriving (Show, Eq)  

-- | A template to track one specific license renewal request.
-- Note that multiple of these can be in flight at any point in time.
template LicenseRenewalRequest with
    provider : Party
    user : Party
    dso : Party
    licenseNum : Int
    licenseFeeAmount : Decimal
    licenseFeeInstrumentId : InstrumentId
    licenseExtensionDuration : RelTime
    reference : ContractId AppPaymentRequest
    prepareUntil : Time
    settleBefore : Time
    createdAt : Time
  where 
    signatory user, provider

    postconsuming choice LicenseRenewalRequest_CompleteRenewal : ContractId License
      with
        acceptedPaymentCid : ContractId AcceptedAppPayment
        licenseCid: ContractId License
        transferContext : AppTransferContext
      controller provider
      do
         -- archival happens via the consuming AcceptedAppPayment_Collect choice
         acceptedPayment <- fetchUncheckedButArchiveLater acceptedPaymentCid
         exercise acceptedPaymentCid (AcceptedAppPayment_Collect transferContext)
         openMiningRound <- exercise @OpenMiningRound transferContext.openMiningRound (OpenMiningRound_Fetch provider)
         let expectedAcceptedPayment = AcceptedAppPayment with
               sender = user
               provider
               amuletReceiverAmounts = [ReceiverAmuletAmount provider licenseFeeAmount]
               dso 
               lockedAmulet = acceptedPayment.lockedAmulet
               round = openMiningRound.round
               reference
         acceptedPayment === expectedAcceptedPayment
         license <- fetchAndArchive Group {user, provider, dso} licenseCid
         licenseNum === license.licenseNum
         now <- getTime
         create License with
                    dso
                    user
                    provider
                    licenseNum
                    params = license.params
                    expiresAt = (max now license.expiresAt) `addRelTime` licenseExtensionDuration

    interface instance AllocationRequest for LicenseRenewalRequest where
          view = AllocationRequestView with
            settlement = SettlementInfo with
              executor = provider
              settlementRef = Reference with
                id = "LicenseRenewalRequest"
                cid = None -- Some (coerceContractId self) FIXME self not available here
              requestedAt = createdAt
              allocateBefore = prepareUntil
              settleBefore = settleBefore
            transferLegs =
              [ TransferLeg with
                  sender = user
                  receiver = provider
                  amount = licenseFeeAmount
                  instrumentId = licenseFeeInstrumentId
                  meta = emptyMetadata
              ]
            meta = emptyMetadata

          allocationRequest_RejectImpl _self AllocationRequest_Reject{..} = do
            -- Only the user (the sender of the renewal fee) can reject.
            require "Actor is the user paying the fee" (actor == user)
            pure ChoiceExecutionMetadata with meta = emptyMetadata

          allocationRequest_WithdrawImpl _self _extraArgs =
            -- Executor (provider) can withdraw this request; here we keep it simple and return immediately.
            pure ChoiceExecutionMetadata with meta = emptyMetadata



-- | A license contract between an app provider and an app user to use the app
-- for a specific purpose.
template License with
    provider : Party -- ^ App provider issuing the license.
    user : Party -- ^ App user holding the license.
    dso : Party -- ^ DSO party issuing the CC to be used for billing.
    expiresAt: Time -- ^ Time when the license expires.
    licenseNum : Int -- ^ License number identifying this license among all of the ones granted by the provider to this user.
    params : LicenseParams -- ^ Parameters determining the behavior and purpose of the license.
  where
    signatory provider, user
    
    nonconsuming choice License_Renew : (ContractId LicenseRenewalRequest, ContractId AppPaymentRequest)
      with
        licenseFeeAmount: Decimal      
        licenseExtensionDuration : RelTime
        paymentAcceptanceDuration: RelTime
        description: Text
      controller provider
      do now <- getTime
         paymentRequest <- create AppPaymentRequest with
           provider, dso
           sender = user
           receiverAmounts = [ReceiverAmount provider (PaymentAmount licenseFeeAmount AmuletUnit)]
           description
           expiresAt = now `addRelTime` paymentAcceptanceDuration
         renewalOffer <- create LicenseRenewalRequest
           with
             provider, dso, user 
             licenseFeeAmount
             licenseExtensionDuration
             licenseNum
             licenseFeeInstrumentId = InstrumentId { admin = dso, id = "Amulet" }
             reference = paymentRequest
             prepareUntil = now `addRelTime` paymentAcceptanceDuration -- ????
             settleBefore = now `addRelTime` paymentAcceptanceDuration -- ????
             createdAt = now
         pure (renewalOffer, paymentRequest)


    choice License_Expire : ()
      with
        actor : Party -- Party that initiated the expiration.
        meta : Metadata -- Metadata for this expiration.
      controller actor
      do
        now <- getTime
        require "Actor is a signatory" (actor `elem` signatory this)
        require "License is not expired yet" (now > expiresAt)
        enforceMetadataLimits meta

instance HasCheckedFetch License Group where
  contractGroupId License{..} = Group with ..

