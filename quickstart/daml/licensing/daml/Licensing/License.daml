-- Copyright (c) 2025, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: 0BSD
--
-- | A license contract for a CN application that allows the app provider
--   to charge a fee for renewing the license. The fee is collected using
--   the token standard. This license is not itself a token instrument.
module Licensing.License where

import DA.Time
import DA.Assert
import DA.Action (unless)

import Splice.Util as Util (require, assertWithinDeadline, assertDeadlineExceeded)
import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1

-- | Parameters determining the license behavior.
data LicenseParams = LicenseParams
  with
    meta : Metadata
  deriving (Eq, Show)

-- | A license contract between an app provider and an app user to use the app.
template License
  with
    provider : Party
    user : Party
    dso : Party
    expiresAt : Time
    licenseNum : Int
    params : LicenseParams
  where
    signatory provider, user

    -- | Renews this license by collecting a fee from the user
    --   via the token standard. The actual settlement flow
    --   is defined by the corresponding LicenseRenewalRequest.
    nonconsuming choice License_Renew : ContractId LicenseRenewalRequest
      with
        licenseFeeInstrumentId : InstrumentId
        licenseFeeAmount : Decimal
        licenseExtensionDuration : RelTime
        paymentAcceptanceDuration : RelTime
        requestedAt : Time
        prepareUntil : Time
        settleBefore : Time
        description : Text
      controller provider
      do
        assertDeadlineExceeded "requestedAt" requestedAt
        assertWithinDeadline "prepareUntil" prepareUntil
        require "prepareUntil < settleBefore" (prepareUntil < settleBefore)
        create LicenseRenewalRequest with
          provider
          user
          dso
          licenseNum
          licenseFeeAmount
          licenseFeeInstrumentId
          licenseExtensionDuration
          prepareUntil
          settleBefore
          createdAt = requestedAt
          licenseCid = self

    -- | Used if a provider/user chooses to mark the license as expired
    --   once the time has actually passed.
    choice License_Expire : ()
      with
        actor : Party
        meta : Metadata
      controller actor
      do
        now <- getTime
        require "Actor is a signatory" (actor `elem` signatory this)
        require "License is not expired yet" (now > expiresAt)

-- | A request to renew a license. This is where the token-standard-based
--   fee settlement is driven. The user is asked to pay the renewal fee
--   to the provider. Once settled, the old license is archived and a new
--   license with extended validity is created.
template LicenseRenewalRequest
  with
    provider : Party
    user : Party
    dso : Party
    licenseNum : Int
    licenseFeeAmount : Decimal
    licenseFeeInstrumentId : InstrumentId
    licenseExtensionDuration : RelTime
    prepareUntil : Time
    settleBefore : Time
    createdAt : Time
    licenseCid : ContractId License
  where
    signatory user, provider

    -- | Cancels this renewal request (e.g. if the user rejects or the
    --   provider withdraws the request).
    choice LicenseRenewalRequest_Cancel : ()
      with
        actor : Party
        meta : Metadata
      controller actor
      do
        require "Actor is a signatory" (actor `elem` signatory this)
        unless (actor == user || actor == provider) $
          fail "Actor is not a signatory or the user/provider"
        pure ()

    -- | Completes the renewal by finalizing the token-standard-based fee
    --   transfer via Allocation(s) and creating the new license state.
    --
    --   Once the license fee is transferred, the old license is archived
    --   and replaced with a new license with extended validity.
    postconsuming choice LicenseRenewalRequest_CompleteRenewal : ContractId License
      with
        allocationInstruction : ContractId Allocation
        extraArgs : ExtraArgs
      controller provider
      do
        now <- getTime
        require "Preparation time has passed" (now >= prepareUntil)
        require "Settlement deadline has not passed" (now < settleBefore)

        exercise allocationInstruction (Allocation_ExecuteTransfer extraArgs)

        oldLicense <- fetch licenseCid

        licenseNum === oldLicense.licenseNum
        user === oldLicense.user
        dso === oldLicense.dso
        provider === oldLicense.provider

        archive licenseCid

        now <- getTime
        create oldLicense with
          expiresAt = (max now oldLicense.expiresAt) `addRelTime` licenseExtensionDuration

    interface instance AllocationRequest for LicenseRenewalRequest where
      view =
        AllocationRequestView
          with
            settlement =
              SettlementInfo
                with
                  executor = provider
                  requestedAt = createdAt
                  allocateBefore = prepareUntil
                  settleBefore
                  settlementRef =
                    Reference
                      with
                        id = "LicenseRenewalRequest"
                        cid = Some (coerceContractId licenseCid)
            transferLegs =
              [ Api.Token.AllocationV1.TransferLeg
                  with
                    sender = user
                    receiver = provider
                    amount = licenseFeeAmount
                    instrumentId = licenseFeeInstrumentId
                    meta = emptyMetadata
              ]
            meta = emptyMetadata

      allocationRequest_RejectImpl _ AllocationRequest_Reject{..} = do
        require "Actor is the user paying the fee" (actor == user)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _ _ =
        pure ChoiceExecutionMetadata with meta = emptyMetadata

