-- Copyright (c) 2025, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: 0BSD
--
-- | A license contract for a CN application that allows the app provider
--   to charge a fee for renewing the license. The fee is collected using
--   the token standard. This license is not itself a token instrument.
module Licensing.License where

import DA.Time
import DA.Assert
import DA.Action (unless)
import DA.List (head)

import Splice.Util as Util (require)
import Splice.Api.Token.MetadataV1
import Splice.Api.Token.HoldingV1
import Splice.Api.Token.AllocationRequestV1
import Splice.Api.Token.AllocationV1 as Api.Token.AllocationV1
import Licensing.Util

-- | Parameters determining the license behavior.
data LicenseParams = LicenseParams
  with
    meta : Metadata
  deriving (Eq, Show)

-- | A license contract between an app provider and an app user to use the app.
template License
  with
    provider : Party
    user : Party
    dso : Party
    expiresAt : Time
    licenseNum : Int
    params : LicenseParams
  where
    signatory provider, user

    -- | Renews this license by collecting a fee from the user
    --   via the token standard. The actual settlement flow
    --   is defined by the corresponding LicenseRenewalRequest,
    --   which is an AllocationRequest.
    nonconsuming choice License_Renew : ContractId LicenseRenewalRequest
      with
        licenseFeeAmount : Decimal
        licenseExtensionDuration : RelTime
        paymentAcceptanceDuration : RelTime
        description : Text
      controller provider
      do
        now <- getTime
        let prepareUntil = now `addRelTime` hours 1
        let settleBefore = now `addRelTime` paymentAcceptanceDuration
        create LicenseRenewalRequest with
          provider
          user
          dso
          licenseNum
          licenseFeeAmount
          licenseFeeInstrumentId = InstrumentId { admin = dso, id = "Amulet" }
          licenseExtensionDuration
          prepareUntil
          settleBefore
          createdAt = now
          licenseCid = self

    -- | Used if a provider/user chooses to mark the license as expired
    --   once the time has actually passed.
    choice License_Expire : ()
      with
        actor : Party
        meta : Metadata
      controller actor
      do
        now <- getTime
        require "Actor is a signatory" (actor `elem` signatory this)
        require "License is not expired yet" (now > expiresAt)
        enforceMetadataLimits meta

-- | Groups together the signatories so that we can reference them in fetch calls.
data Group = Group
  with
    user : Party
    provider : Party
    dso : Party
  deriving (Show, Eq)

-- | A request to renew a license. This is where the token-standard-based
--   fee settlement is driven. The user is asked to pay the renewal fee
--   to the provider. Once settled, the old license is archived and a new
--   license with extended validity is created.
template LicenseRenewalRequest
  with
    provider : Party
    user : Party
    dso : Party
    licenseNum : Int
    licenseFeeAmount : Decimal
    licenseFeeInstrumentId : InstrumentId
    licenseExtensionDuration : RelTime
    prepareUntil : Time
    settleBefore : Time
    createdAt : Time
    licenseCid : ContractId License
  where
    signatory user, provider

    -- | Cancels this renewal request (e.g. if the user rejects or the
    --   provider withdraws the request).
    choice LicenseRenewalRequest_Cancel : LicenseRenewalCancel
      with
        actor : Party
        meta : Metadata
      controller actor
      do
        require "Actor is a signatory" (actor `elem` signatory this)
        unless (actor == user || actor == provider) $
          fail "Actor is not a signatory or the user/provider"
        pure LicenseRenewalCancel with
          actor
          meta

    -- | Completes the renewal by finalizing the token-standard-based fee
    --   transfer via Allocation(s) and creating the new license state.
    --
    --   Once the license fee is transferred, the old license is archived
    --   and replaced with a new license with an updated expiry.
    postconsuming choice LicenseRenewalRequest_CompleteRenewal : ContractId License
      with
        allocationInstructions : [ContractId Allocation]
        extraArgss : [ExtraArgs]
      controller provider
      do
        now <- getTime
        require "Preparation time has passed" (now >= prepareUntil)
        require "Settlement deadline has not passed" (now < settleBefore)
        require "Exactly one allocation instruction" (length allocationInstructions == 1)
        require "Exactly one extraArgs" (length extraArgss == 1)

        let allocCid = head allocationInstructions
        exercise allocCid (Allocation_ExecuteTransfer (head extraArgss))

        oldLicense <- fetch licenseCid
        archive licenseCid
        licenseNum === oldLicense.licenseNum

        now <- getTime
        create oldLicense with
          expiresAt = (max now oldLicense.expiresAt) `addRelTime` licenseExtensionDuration

    interface instance AllocationRequest for LicenseRenewalRequest where
      view =
        AllocationRequestView
          with
            settlement =
              SettlementInfo
                with
                  executor = provider
                  requestedAt = createdAt
                  allocateBefore = prepareUntil
                  settleBefore
                  settlementRef =
                    Reference
                      with
                        id = "LicenseRenewalRequest"
                        cid = Some (coerceContractId licenseCid)
            transferLegs =
              [ Api.Token.AllocationV1.TransferLeg
                  with
                    sender = user
                    receiver = provider
                    amount = licenseFeeAmount
                    instrumentId = licenseFeeInstrumentId
                    meta = emptyMetadata
              ]
            meta = emptyMetadata

      allocationRequest_RejectImpl _ AllocationRequest_Reject{..} = do
        require "Actor is the user paying the fee" (actor == user)
        pure ChoiceExecutionMetadata with meta = emptyMetadata

      allocationRequest_WithdrawImpl _ _ =
        pure ChoiceExecutionMetadata with meta = emptyMetadata

-- | Information about a renewal cancellation, storing who cancelled and why.
data LicenseRenewalCancel = LicenseRenewalCancel
  with
    actor : Party
    meta : Metadata
  deriving (Eq, Show)
